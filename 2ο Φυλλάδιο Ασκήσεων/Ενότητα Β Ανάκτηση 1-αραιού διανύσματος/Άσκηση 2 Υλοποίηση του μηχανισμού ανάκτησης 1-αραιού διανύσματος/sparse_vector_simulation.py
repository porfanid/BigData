# ONOMA: Ανδρεόπουλος Ευστάθιος 	ΑΜ: 4630    EMAIL: cs04630@uoi.gr
# ONOMA: Ορφανίδης Παύλος 			ΑΜ: 4134    EMAIL: cs04134@uoi.gr
import numpy as np  # Εισαγωγή numpy για αριθμητικούς υπολογισμούς και διανύσματα
import random  # Εισαγωγή random για τυχαίους αριθμούς


class SparseVectorRecovery:
    """
    Κλάση που υλοποιεί μηχανισμό ανάκτησης 1-αραιού διανύσματος.
    
    Χρησιμοποιεί αλγόριθμο βασισμένο σε πολυώνυμα για να ανιχνεύσει
    αν ένα διάνυσμα έχει ακριβώς μία μη-μηδενική συντεταγμένη και
    να εντοπίσει ποια είναι αυτή η συντεταγμένη.
    """
    
    def __init__(self, n=10000, p=20011, T=1):
        """
        Αρχικοποιεί τον μηχανισμό ανάκτησης 1-αραιού διανύσματος.
        
        Δημιουργεί τυχαίους αριθμούς και αρχικοποιεί τα διανύσματα
        που θα χρησιμοποιηθούν για την ανίχνευση αραιότητας.
        
        Args:
            n (int): Μέγεθος του διανύσματος (default: 10000)
            p (int): Πρώτος αριθμός για modular arithmetic (default: 20011)
            T (int): Πλήθος τυχαίων αριθμών για αυξημένη ακρίβεια (default: 1)
        """
        self.n = n  # Αποθήκευση μεγέθους διανύσματος
        self.p = p  # Αποθήκευση πρώτου αριθμού
        self.T = T  # Αποθήκευση αριθμού τυχαίων παραμέτρων

        self.x = np.zeros(n + 1)  # Δημιουργία διανύσματος με δείκτες από 1 έως n

        self.r = [random.randint(1, p - 1) for _ in range(T)]  # Παραγωγή T τυχαίων αριθμών από 1 έως p-1

        self.a = [0] * T  # Αρχικοποίηση διανύσματος a για αποθήκευση σταθμισμένων αθροισμάτων
        self.b = [0] * T  # Αρχικοποίηση διανύσματος b για αποθήκευση απλών αθροισμάτων

    def process_command(self, i, c):
        """
        Επεξεργάζεται μια εντολή τροποποίησης διανύσματος.
        
        Ενημερώνει το διάνυσμα x και τα βοηθητικά διανύσματα a, b
        που χρησιμοποιούνται για την ανίχνευση αραιότητας.
        
        Args:
            i (int): Δείκτης συντεταγμένης προς τροποποίηση
            c (int): Τιμή που θα προστεθεί στη συντεταγμένη
        """
        self.x[i] += c  # Ενημέρωση της συντεταγμένης i με την τιμή c

        for t in range(self.T):  # Επανάληψη για κάθε τυχαία παράμετρο
            r_i_power = pow(self.r[t], i, self.p)  # Υπολογισμός r_t^i mod p
            self.a[t] = (self.a[t] + c * r_i_power) % self.p  # Ενημέρωση σταθμισμένου αθροίσματος
            self.b[t] = (self.b[t] + c) % self.p  # Ενημέρωση απλού αθροίσματος

    def is_1_sparse(self):
        """
        Ελέγχει αν το διάνυσμα είναι 1-αραιό.
        
        Χρησιμοποιεί τα διανύσματα a και b για να καθορίσει αν το διάνυσμα
        περιέχει ακριβώς μία μη-μηδενική συντεταγμένη.
        
        Returns:
            bool: True αν το διάνυσμα φαίνεται 1-αραιό, False διαφορετικά
        """
        if all(b_t == 0 for b_t in self.b):  # Έλεγχος αν όλα τα b_t είναι μηδέν
            return False  # Το διάνυσμα είναι 0-αραιό (όχι 1-αραιό)

        for t in range(self.T):  # Επανάληψη για κάθε τυχαία παράμετρο
            if self.b[t] == 0 and self.a[t] != 0:  # Αν b_t=0 αλλά a_t≠0
                return False  # Ασυνέπεια, δεν είναι 1-αραιό

            if self.b[t] != 0:  # Αν το b_t δεν είναι μηδέν
                b_inv = pow(self.b[t], -1, self.p)  # Υπολογισμός πολλαπλασιαστικού αντιστρόφου
                result = (self.a[t] * b_inv) % self.p  # Υπολογισμός a_t/b_t mod p

                found = False  # Σημαία για έλεγχο ύπαρξης λύσης
                for j in range(1, self.n + 1):  # Έλεγχος όλων των δυνατών δεικτών
                    if pow(self.r[t], j, self.p) == result:  # Αν r_t^j ≡ result (mod p)
                        found = True  # Βρέθηκε έγκυρος δείκτης
                        break  # Διακοπή αναζήτησης

                if not found:  # Αν δεν βρέθηκε έγκυρος δείκτης
                    return False  # Το διάνυσμα δεν είναι 1-αραιό

        return True  # Όλοι οι έλεγχοι πέρασαν, το διάνυσμα είναι 1-αραιό

    def get_non_zero_coordinate(self):
        """
        Επιστρέφει τη μη-μηδενική συντεταγμένη και την τιμή της.
        
        Λειτουργεί μόνο όταν το διάνυσμα είναι 1-αραιό.
        
        Returns:
            tuple: (δείκτης, τιμή) της μη-μηδενικής συντεταγμένης ή (None, None)
        """
        if not self.is_1_sparse():  # Έλεγχος αν το διάνυσμα είναι 1-αραιό
            return None, None  # Δεν είναι 1-αραιό, επιστροφή None

        if self.b[0] == 0:  # Αν το πρώτο στοιχείο του b είναι μηδέν
            return None, None  # Δεν υπάρχει μη-μηδενική συντεταγμένη

        b_inv = pow(self.b[0], -1, self.p)  # Υπολογισμός αντιστρόφου του b[0]
        result = (self.a[0] * b_inv) % self.p  # Υπολογισμός a[0]/b[0] mod p

        for i in range(1, self.n + 1):  # Αναζήτηση του δείκτη
            if pow(self.r[0], i, self.p) == result:  # Αν r[0]^i ≡ result (mod p)
                return i, self.b[0]  # Επιστροφή δείκτη και τιμής

        return None, None  # Δεν βρέθηκε έγκυρος δείκτης


def run_simulation(T=1, n_commands=10_000_000):
    """
    Εκτελεί προσομοίωση του μηχανισμού ανάκτησης 1-αραιού διανύσματος.
    
    Δημιουργεί εντολές, τις εφαρμόζει στον μηχανισμό και μετράει
    τα false positives (λάθος ανιχνεύσεις 1-αραιότητας).
    
    Args:
        T (int): Αριθμός τυχαίων παραμέτρων για τον αλγόριθμο
        n_commands (int): Συνολικός αριθμός εντολών προς εκτέλεση
        
    Returns:
        int: Αριθμός false positive σφαλμάτων
    """
    from command_generator import generate_commands  # Εισαγωγή συνάρτησης παραγωγής εντολών
    print(f"Παράγονται {n_commands} εντολές...")  # Ενημερωτικό μήνυμα έναρξης
    commands = generate_commands(n_commands)  # Παραγωγή λίστας εντολών
    print("Ολοκληρώθηκε η παραγωγή εντολών.")  # Ενημερωτικό μήνυμα ολοκλήρωσης

    recovery = SparseVectorRecovery(n=10000, p=20011, T=T)  # Δημιουργία αντικειμένου ανάκτησης

    errors = 0  # Αρχικοποίηση μετρητή σφαλμάτων

    x = np.zeros(10001)  # Δημιουργία διανύσματος για επαλήθευση

    print(f"Εκτέλεση προσομοίωσης με T={T}...")  # Ενημερωτικό μήνυμα έναρξης εκτέλεσης
    for idx, (i, c) in enumerate(commands, 1):  # Επανάληψη για κάθε εντολή με αρίθμηση από 1
        x[i] += c  # Εφαρμογή εντολής στο διάνυσμα επαλήθευσης

        recovery.process_command(i, c)  # Εφαρμογή εντολής στον μηχανισμό ανάκτησης

        is_1_sparse_algorithm = recovery.is_1_sparse()  # Έλεγχος 1-αραιότητας από αλγόριθμο

        non_zero_count = np.count_nonzero(x)  # Πραγματικός υπολογισμός μη-μηδενικών στοιχείων
        is_1_sparse_actual = (non_zero_count == 1)  # Πραγματικός έλεγχος 1-αραιότητας

        if is_1_sparse_algorithm and not is_1_sparse_actual:  # Αν υπάρχει false positive
            errors += 1  # Αύξηση μετρητή σφαλμάτων

        if idx % 100000 == 0 or idx == n_commands:  # Κάθε 100,000 εντολές ή στο τέλος
            print(f"{idx}: {errors}")  # Εκτύπωση προόδου και σφαλμάτων

    return errors  # Επιστροφή συνολικού αριθμού σφαλμάτων


def run_multiple_simulations(max_T=10, n_commands=10_000_000):
    """
    Εκτελεί πολλαπλές προσομοιώσεις για διαφορετικές τιμές του T.
    
    Δοκιμάζει τον αλγόριθμο με διαφορετικό αριθμό τυχαίων παραμέτρων
    για να αξιολογήσει την επίδραση του T στην ακρίβεια.
    
    Args:
        max_T (int): Μέγιστη τιμή του T για δοκιμή
        n_commands (int): Αριθμός εντολών ανά προσομοίωση
        
    Returns:
        dict: Λεξικό με αποτελέσματα {T: αριθμός_σφαλμάτων}
    """
    results = {}  # Αρχικοποίηση λεξικού αποτελεσμάτων
    for T in range(1, max_T + 1):  # Επανάληψη για κάθε τιμή T από 1 έως max_T
        print(f"\nΠροσομοίωση με T={T}")  # Ενημερωτικό μήνυμα έναρξης
        errors = run_simulation(T=T, n_commands=n_commands)  # Εκτέλεση προσομοίωσης
        results[T] = errors  # Αποθήκευση αποτελέσματος
        print(f"Αποτέλεσμα για T={T}: {errors} σφάλματα")  # Εκτύπωση αποτελέσματος

    return results  # Επιστροφή όλων των αποτελεσμάτων


if __name__ == "__main__":  # Έλεγχος αν το script εκτελείται απευθείας
    errors = run_simulation(T=2, n_commands=10000)  # Εκτέλεση δοκιμαστικής προσομοίωσης
    print(f"Συνολικά σφάλματα: {errors}")  # Εκτύπωση συνολικών σφαλμάτων
    
    # Αποθήκευση αποτελεσμάτων σε αρχείο
    with open("simulation_results.txt", "w", encoding="utf-8-sig") as f:  # Άνοιγμα αρχείου για εγγραφή
        f.write(f"Αποτελέσματα προσομοίωσης:\n")  # Εγγραφή τίτλου
        f.write(f"T=2, n_commands=10000\n")  # Εγγραφή παραμέτρων
        f.write(f"Συνολικά σφάλματα: {errors}\n")  # Εγγραφή αποτελέσματος
