# ONOMA: Ανδρεόπουλος Ευστάθιος 	ΑΜ: 4630    EMAIL: cs04630@uoi.gr
# ONOMA: Ορφανίδης Παύλος 			ΑΜ: 4134    EMAIL: cs04134@uoi.gr

# --- Εισαγωγή απαραίτητων βιβλιοθηκών ---
import numpy as np                        # Βιβλιοθήκη για αποδοτικούς υπολογισμούς με πίνακες
import math                               # Μαθηματικές συναρτήσεις όπως log2 και ceil
import matplotlib.pyplot as plt           # Βιβλιοθήκη για σχεδίαση γραφημάτων
from fractions import Fraction            # Για ακριβείς πράξεις με ρητούς αριθμούς (π.χ. 1/3)

# --- Συνάρτηση υπολογισμού των πιθανοτήτων P(C_k = i) για τον Morris Counter ---
def efficient_probability_calculation(max_k=1000, max_i=11):
    """
    Υπολογίζει τις πιθανότητες P(C_k = i) με χρήση της στοχαστικής συμπεριφοράς του μετρητή Morris,
    χρησιμοποιώντας ακριβή αριθμητική (Fraction) και δυναμικό προγραμματισμό.
    
    Παράμετροι:
        max_k: μέγιστος αριθμός βημάτων k
        max_i: μέγιστο επίπεδο κατάστασης i
        
    Επιστρέφει:
        Πίνακα P με P[k][i] = P(C_k = i)
    """

    # Δημιουργία πίνακα πιθανοτήτων διαστάσεων (max_k + 1) x (max_i + 1)
    P = np.empty((max_k + 1, max_i + 1), dtype=object)

    # Αρχικοποίηση όλων των στοιχείων του πίνακα με 0 (ρητός αριθμός)
    for k in range(max_k + 1):
        for i in range(max_i + 1):
            P[k, i] = Fraction(0, 1)

    # Αρχική συνθήκη: στο βήμα 0 ο μετρητής είναι σίγουρα στην κατάσταση 0
    P[0, 0] = Fraction(1, 1)

    # Υπολογισμός πιθανοτήτων με δυναμικό προγραμματισμό
    for k in range(1, max_k + 1):
        # Η πιθανότητα να βρισκόμαστε στην κατάσταση 0 όταν k ≥ 1 είναι 0
        P[k, 0] = Fraction(0, 1)

        # Υπολογισμός για όλες τις υπόλοιπες καταστάσεις i > 0
        for i in range(1, max_i + 1):
            # Πιθανότητα να παραμείνουμε στην ίδια κατάσταση (δεν αυξάνεται)
            stay = P[k - 1, i] * (1 - Fraction(1, 2 ** i))
            # Πιθανότητα να αυξηθούμε από την κατάσταση i-1 στην i
            inc  = P[k - 1, i - 1] * Fraction(1, 2 ** (i - 1))
            # Συνολική πιθανότητα να βρισκόμαστε στην κατάσταση i στο βήμα k
            P[k, i] = stay + inc

    return P  # Επιστρέφει τον πίνακα πιθανοτήτων

# --- Κύρια συνάρτηση main: συλλογή και ανάλυση των πιθανοτήτων ---
def main():
    max_k, max_i = 1000, 11  # Ορισμός ορίων για τα k και i
    P = efficient_probability_calculation(max_k, max_i)  # Υπολογισμός πιθανοτήτων

    ks = range(1, max_k + 1)      # k από 1 έως 1000
    probabilities = []            # Λίστα για αποθήκευση των πιθανοτήτων

    # Για κάθε βήμα k, υπολογίζουμε την πιθανότητα το C_k να είναι κοντά στην αναμενόμενη τιμή
    for k in ks:
        # Υπολογισμός της θεωρητικής εκτίμησης: i(k) = ceil(log2(k+1))
        i_val = int(math.ceil(math.log2(k + 1)))
        
        # Υπολογισμός του αθροίσματος των πιθανοτήτων για τις καταστάσεις: i(k)-1, i(k), i(k)+1
        prob_sum = Fraction(0, 1)
        for offset in [-1, 0, 1]:
            idx = i_val + offset
            # Έλεγχος ότι η κατάσταση είναι εντός ορίων
            if 0 <= idx <= max_i:
                prob_sum += P[k, idx]

        # Μετατροπή σε δεκαδικό για το γράφημα
        probabilities.append(float(prob_sum))

    # --- Σχεδίαση του γραφήματος ---
    plt.figure(figsize=(8, 5))  # Ορισμός διαστάσεων παραθύρου

    # Σχεδίαση της καμπύλης: πιθανότητα να είμαστε σε μία από τις τρεις τιμές γύρω από την αναμενόμενη
    plt.plot(
        ks, 
        probabilities, 
        label=r"$P\left(C_k \in \{\lceil \log_{2}(k+1)\rceil - 1,\;\lceil \log_{2}(k+1)\rceil,\;\lceil \log_{2}(k+1)\rceil + 1\}\right)$"
    )

    # Προσθήκη τίτλων και ετικετών
    plt.xlabel("k")
    plt.ylabel("Πιθανότητα")
    plt.title("Morris Counter: P(C_k ∈ { i(k)-1, i(k), i(k)+1 }) για k=1..1000 (με ανώτερο όριο)")

    # Υπόμνημα και πλέγμα
    plt.legend()
    plt.grid(True)
    plt.show()  # Εμφάνιση γραφήματος

# --- Εκτέλεση της κύριας συνάρτησης ---
if __name__ == "__main__":
    main()
