# ONOMA: Ανδρεόπουλος Ευστάθιος 	ΑΜ: 4630    EMAIL: cs04630@uoi.gr
# ONOMA: Ορφανίδης Παύλος 			ΑΜ: 4134    EMAIL: cs04134@uoi.gr

# Εισαγωγή απαραίτητων βιβλιοθηκών
import numpy as np                      # Για αποδοτική διαχείριση πινάκων
import math                             # Για μαθηματικές συναρτήσεις όπως log2 και ceil
import matplotlib.pyplot as plt         # Για σχεδίαση γραφημάτων
from fractions import Fraction          # Για ακριβείς υπολογισμούς με ρητούς αριθμούς

def efficient_probability_calculation(max_k=1000, max_i=11):
    """
    Υπολογίζει τις πιθανότητες P(C_k = i) χρησιμοποιώντας τη
    δυναμική του Morris counter, με ακριβή αριθμητική (Fraction).
    
    max_k: Μέγιστος αριθμός βημάτων του μετρητή
    max_i: Μέγιστο επίπεδο κατάστασης που εξετάζουμε
    Επιστρέφει: Πίνακα P τέτοιο ώστε P[k, i] = P(C_k = i)
    """
    
    # Δημιουργία πίνακα P διαστάσεων (max_k+1) x (max_i+1), τύπου object για χρήση με Fraction
    P = np.empty((max_k + 1, max_i + 1), dtype=object)
    
    # Αρχικοποίηση όλων των στοιχείων του πίνακα με 0 (ρητός αριθμός)
    for k in range(max_k + 1):
        for i in range(max_i + 1):
            P[k, i] = Fraction(0, 1)

    # Αρχική συνθήκη: Στο βήμα 0, ο μετρητής είναι σίγουρα στην κατάσταση 0
    P[0, 0] = Fraction(1, 1)

    # Υπολογισμός των πιθανοτήτων με χρήση δυναμικού προγραμματισμού
    for k in range(1, max_k + 1):
        # Ο μετρητής δεν μπορεί να είναι στην κατάσταση 0 μετά το πρώτο βήμα
        P[k, 0] = Fraction(0, 1)

        # Υπολογισμός πιθανοτήτων για κάθε δυνατή κατάσταση i > 0
        for i in range(1, max_i + 1):
            # Πιθανότητα να παραμείνει στην ίδια κατάσταση (δεν αυξάνει)
            stay = P[k - 1, i] * (1 - Fraction(1, 2 ** i))
            # Πιθανότητα να αυξηθεί από την i-1 στην i
            inc = P[k - 1, i - 1] * Fraction(1, 2 ** (i - 1))
            # Συνολική πιθανότητα να βρίσκεται στην κατάσταση i στο βήμα k
            P[k, i] = stay + inc

    return P  # Επιστροφή του πίνακα πιθανοτήτων

def main():
    max_k, max_i = 1000, 11  # Ορισμός των μέγιστων τιμών για k και i

    # Υπολογισμός του πίνακα πιθανοτήτων
    P = efficient_probability_calculation(max_k, max_i)

    ks = range(1, max_k + 1)  # Όλες οι τιμές του k από 1 έως 1000
    probabilities = []        # Λίστα για την αποθήκευση των πιθανοτήτων

    # Για κάθε τιμή του k υπολογίζουμε την πιθανότητα:
    # να βρίσκεται ο μετρητής στην κατάσταση ceil(log2(k+1))
    for k in ks:
        i = int(math.ceil(math.log2(k + 1)))  # Υπολογισμός της κατάστασης με βάση το ταβάνι του log2(k+1)
        prob = float(P[k, i])                 # Ανάγνωση της πιθανότητας από τον πίνακα και μετατροπή σε float
        probabilities.append(prob)            # Αποθήκευση της πιθανότητας στη λίστα

    # Σχεδίαση γραφήματος
    plt.figure(figsize=(8, 5))  # Ορισμός μεγέθους του γραφήματος

    # Σχεδίαση της καμπύλης: P(C_k = ceil(log2(k+1))) για κάθε k
    plt.plot(ks, probabilities, label=r"$P\left(C_k = \lceil \log_{2}(k+1)\rceil\right)$")

    # Ορισμός τίτλου και ετικετών
    plt.xlabel("k")
    plt.ylabel("Probability")
    plt.title("Morris Counter: P(C_k = ceil(log2(k+1))) για k=1..1000")
    plt.legend()        # Προσθήκη υπομνήματος
    plt.grid(True)      # Ενεργοποίηση πλέγματος για ευκολότερη ανάγνωση
    plt.show()          # Εμφάνιση του γραφήματος

# Εκτέλεση της main συνάρτησης
if __name__ == "__main__":
    main()
