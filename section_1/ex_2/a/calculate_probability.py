import numpy as np
import matplotlib.pyplot as plt
from fractions import Fraction
import math


def efficient_probability_calculation(max_k=1000, max_i=20):
    """
    Υπολογίζει τις πιθανότητες P(C_k = i) για k από 1 έως max_k και i από 0 έως max_i
    χρησιμοποιώντας δυναμικό προγραμματισμό.

    Αυτή η συνάρτηση υλοποιεί μια αποδοτική μέθοδο υπολογισμού της κατανομής πιθανοτήτων
    του μετρητή Morris, ο οποίος είναι ένας πιθανοτικός αλγόριθμος μέτρησης.

    Βασικές παράμετροι:
    - max_k: Μέγιστος αριθμός ενημερώσεων του μετρητή προς υπολογισμό
    - max_i: Μέγιστη τιμή μετρητή προς εξέταση

    Επιστρέφει έναν 2D πίνακα πιθανοτήτων χρησιμοποιώντας Fraction για ακριβείς υπολογισμούς
    """
    # Αρχικοποίηση 2D πίνακα για την αποθήκευση πιθανοτήτων
    # Χρησιμοποιούμε dtype=object για να υποστηρίξουμε τύπο Fraction
    # Γραμμές αναπαριστούν το k (αριθμός ενημερώσεων)
    # Στήλες αναπαριστούν το i (τιμή μετρητή)
    P = np.zeros((max_k + 1, max_i + 1), dtype=object)

    # Αρχική συνθήκη: Όταν δεν έχουν γίνει ενημερώσεις (k = 0),
    # η πιθανότητα να είναι στο 0 είναι 1
    # Αυτό ορίζει το σημείο εκκίνησης για τον υπολογισμό
    P[0, 0] = Fraction(1, 1)

    # Διπλός βρόχος για υπολογισμό πιθανοτήτων για κάθε k και i
    for k in range(1, max_k + 1):
        for i in range(max_i + 1):
            if i == 0:
                # Ειδική περίπτωση: Αν ο μετρητής είναι 0,
                # η πιθανότητα παραμένει ίδια με την προηγούμενη κατάσταση
                # Αναπαριστά την περίπτωση που δεν γίνεται καμία αύξηση
                P[k, i] = P[k - 1, i]
            else:
                # Γενική περίπτωση: Υπολογισμός πιθανοτήτων με δύο σενάρια
                # 1. Πιθανότητα παραμονής στο τρέχον επίπεδο
                # P(C_{k-1} = i) * (1 - πιθανότητα αύξησης)
                p1 = P[k - 1, i] * (1 - Fraction(1, 2 ** i))

                # 2. Πιθανότητα αύξησης από το προηγούμενο επίπεδο
                # P(C_{k-1} = i-1) * (πιθανότητα αύξησης)
                p2 = P[k - 1, i - 1] * Fraction(1, 2 ** (i - 1))

                # Συνολική πιθανότητα είναι το άθροισμα των δύο παραπάνω σεναρίων
                P[k, i] = p1 + p2

    return P


def probability_c_k_equals_l_k(max_k=1000):
    """
    Υπολογίζει την πιθανότητα ο μετρητής να ισούται με το ⌈log_2(k+1)⌉

    Παράμετροι:
    - max_k: Μέγιστος αριθμός ενημερώσεων προς εξέταση

    Επιστρέφει λίστα πιθανοτήτων για κάθε k
    """
    # Υπολογισμός όλων των πιθανοτήτων με την προηγούμενη συνάρτηση
    P = efficient_probability_calculation(max_k)
    probabilities = []

    # Υπολογισμός της πιθανότητας για κάθε k
    for k in range(1, max_k + 1):
        # Υπολογισμός της τιμής l(k) ως το ανώτατο ακέραιο μέρος του log_2(k+1)
        l_k = math.ceil(math.log2(k + 1))

        # Μετατροπή της πιθανότητας σε δεκαδικό αριθμό
        probability = float(P[k, l_k])
        probabilities.append(probability)

    return probabilities


def probability_c_k_near_l_k(max_k=1000):
    """
    Υπολογίζει την πιθανότητα ο μετρητής να βρίσκεται κοντά στο l(k)
    Συγκεκριμένα, υπολογίζει P(C_k ∈ {l(k)-1, l(k), l(k)+1})

    Παράμετροι:
    - max_k: Μέγιστος αριθμός ενημερώσεων προς εξέταση

    Επιστρέφει λίστα πιθανοτήτων για κάθε k
    """
    # Υπολογισμός πιθανοτήτων με επιπλέον εύρος για να καλύψει τις γειτονικές τιμές
    P = efficient_probability_calculation(max_k, max_i=math.ceil(math.log2(max_k + 1)) + 2)
    probabilities = []

    for k in range(1, max_k + 1):
        # Υπολογισμός της τιμής l(k)
        l_k = math.ceil(math.log2(k + 1))

        # Αρχικοποίηση συνολικής πιθανότητας
        total_prob = Fraction(0, 1)

        # Προσθήκη P(C_k = l(k)-1) αν l(k) > 0
        if l_k > 0:
            total_prob += P[k, l_k - 1]

        # Προσθήκη P(C_k = l(k))
        total_prob += P[k, l_k]

        # Προσθήκη P(C_k = l(k)+1)
        total_prob += P[k, l_k + 1]

        # Μετατροπή σε δεκαδικό αριθμό
        probabilities.append(float(total_prob))

    return probabilities


def plot_probabilities():
    """
    Δημιουργία γραφικών παραστάσεων για τα ερωτήματα 2β και 2γ

    Υπολογίζει και απεικονίζει:
    1. Πιθανότητα ο μετρητής να ισούται με ⌈log_2(k+1)⌉
    2. Πιθανότητα ο μετρητής να βρίσκεται κοντά στο l(k)
    """
    # Υπολογισμός πιθανοτήτων
    probs_exact = probability_c_k_equals_l_k(1000)
    probs_range = probability_c_k_near_l_k(1000)

    # Γραφική παράσταση για το 2β - Ακριβής τιμή
    plt.figure(figsize=(10, 6))
    plt.plot(range(1, 1001), probs_exact)
    plt.xlabel('k')
    plt.ylabel('P(C_k = ⌈log_2(k+1)⌉)')
    plt.title('Πιθανότητα ισότητας με το ανώτατο ακέραιο μέρος του log_2(k+1)')
    plt.grid(True)
    plt.savefig('morris_probabilities_2b.png')
    plt.close()

    # Γραφική παράσταση για το 2γ - Εύρος τιμών
    plt.figure(figsize=(10, 6))
    plt.plot(range(1, 1001), probs_range)
    plt.xlabel('k')
    plt.ylabel('P(C_k ∈ {l(k)-1, l(k), l(k)+1})')
    plt.title('Πιθανότητα εύρεσης κοντά στο ανώτατο ακέραιο μέρος του log_2(k+1)')
    plt.grid(True)
    plt.savefig('morris_probabilities_2c.png')
    plt.close()

    return probs_exact, probs_range


# Εκτέλεση των συναρτήσεων
probs_exact, probs_range = plot_probabilities()

# Συμπέρασμα για το 2γ
print("Συμπέρασμα για το 2γ:")
print(
    "Από τη γραφική παράσταση παρατηρούμε ότι η πιθανότητα η C_k να είναι κοντά στην τιμή log_2(k+1) (δηλαδή να διαφέρει το πολύ κατά 1) είναι πολύ υψηλή και αυξάνεται καθώς αυξάνεται το k. Αυτό δείχνει ότι ο μετρητής Morris είναι αρκετά ακριβής σε μεγάλους αριθμούς στοιχείων όταν λαμβάνουμε υπόψη μας ένα εύρος τιμών γύρω από την ιδανική τιμή.")