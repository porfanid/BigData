import math
from fractions import Fraction


def calculate_path_probabilities(max_k=1000):
    """
    Υπολογίζει δύο σημαντικές πιθανότητες για τον μετρητή Morris:
    1) Την πιθανότητα η C_k να είναι ακριβώς l(k) για όλα τα k στο {1, 2, ..., max_k}
    2) Την πιθανότητα η C_k να ανήκει στο {l(k)-1, l(k), l(k)+1} για όλα τα k

    Παράμετροι:
    - max_k: Μέγιστος αριθμός βημάτων προς εξέταση

    Επιστρέφει:
    - Πιθανότητα ακριβούς τιμής l(k)
    - Πιθανότητα εύρους τιμών γύρω από l(k)
    """
    # Υπολογισμός του μέγιστου επιπέδου του μετρητή
    # Προσθέτουμε 2 για επιπλέον ασφάλεια και κάλυψη γειτονικών τιμών
    max_i = math.ceil(math.log2(max_k + 1)) + 2

    # Δημιουργία 2D λίστας για αποθήκευση πιθανοτήτων
    # prob[k][i] = πιθανότητα ο μετρητής να είναι ίσος με i στο βήμα k
    prob = [[Fraction(0, 1) for _ in range(max_i + 1)] for _ in range(max_k + 1)]

    # Αρχική συνθήκη: Στο βήμα 0, ο μετρητής είναι 0 με βεβαιότητα
    prob[0][0] = Fraction(1, 1)

    # Υπολογισμός πιθανοτήτων για κάθε βήμα και κάθε πιθανή τιμή
    for k in range(1, max_k + 1):
        for i in range(max_i):
            # Υπολογισμός πιθανότητας παραμονής στην τρέχουσα τιμή
            # Ειδική περίπτωση για i=0 λόγω διαφορετικής συμπεριφοράς
            p_stay = Fraction(1, 1) - Fraction(1, 2 ** i) if i > 0 else Fraction(0, 1)

            # Υπολογισμός πιθανότητας αύξησης στην επόμενη τιμή
            # Ειδική περίπτωση για i=0 όπου η πιθανότητα αύξησης είναι 1
            p_inc = Fraction(1, 2 ** i) if i > 0 else Fraction(1, 1)

            # Ενημέρωση πιθανοτήτων για το επόμενο βήμα
            # Πιθανότητα παραμονής στην ίδια τιμή
            prob[k][i] += prob[k - 1][i] * p_stay
            # Πιθανότητα αύξησης στην επόμενη τιμή
            prob[k][i + 1] += prob[k - 1][i] * p_inc

    # Υπολογισμός πιθανότητας ακριβούς τιμής l(k)
    # Ξεκινάμε με πιθανότητα 1 και την πολλαπλασιάζουμε για κάθε βήμα
    exact_prob = Fraction(1, 1)
    for k in range(1, max_k + 1):
        # Υπολογισμός του l(k) για το τρέχον βήμα
        l_k = math.ceil(math.log2(k + 1))

        # Για το πρώτο βήμα, απλά χρησιμοποιούμε την πιθανότητα
        if k == 1:
            exact_prob *= prob[k][l_k]
        else:
            # Για επόμενα βήματα, υπολογίζουμε την πιθανότητα μετάβασης
            # Υπολογισμός του προηγούμενου επιπέδου l
            prev_l = math.ceil(math.log2(k))

            # Διαφορετικές περιπτώσεις μετάβασης μεταξύ επιπέδων
            if l_k == prev_l:
                # Πιθανότητα παραμονής στο ίδιο επίπεδο
                transition_prob = Fraction(1, 1) - Fraction(1, 2 ** prev_l)
            elif l_k == prev_l + 1:
                # Πιθανότητα αύξησης κατά 1
                transition_prob = Fraction(1, 2 ** prev_l)
            else:
                # Αδύνατη μετάβαση σε άλλα επίπεδα
                transition_prob = Fraction(0, 1)

            # Πολλαπλασιασμός με την πιθανότητα μετάβασης
            exact_prob *= transition_prob

    # Υπολογισμός πιθανότητας εύρους τιμών
    range_prob = Fraction(1, 1)
    for k in range(1, max_k + 1):
        # Υπολογισμός του l(k)
        l_k = math.ceil(math.log2(k + 1))

        # Αρχικοποίηση πιθανότητας για το εύρος τιμών
        range_prob_k = Fraction(0, 1)

        # Προσθήκη πιθανοτήτων για τιμές γύρω από l(k)
        if l_k > 0:
            range_prob_k += prob[k][l_k - 1]
        range_prob_k += prob[k][l_k]
        if l_k + 1 <= max_i:
            range_prob_k += prob[k][l_k + 1]

        # Πολλαπλασιασμός με την πιθανότητα του τρέχοντος βήματος
        range_prob *= range_prob_k

    # Επιστροφή των πιθανοτήτων σε δεκαδική μορφή
    return float(exact_prob), float(range_prob)


# Κύριο σημείο εισόδου του προγράμματος
if __name__ == "__main__":
    # Αρχική δοκιμή με μικρό αριθμό βημάτων για έλεγχο
    test_k = 20

    # Υπολογισμός πιθανοτήτων για τον μικρό αριθμό βημάτων
    exact_path_prob, range_path_prob = calculate_path_probabilities(test_k)

    # Εκτύπωση αποτελεσμάτων
    print(f"1) Πιθανότητα η C_k να είναι ακριβώς l(k) για όλα τα k από 1 έως {test_k}: {exact_path_prob:.12f}")
    print(
        f"2) Πιθανότητα η C_k να ανήκει στο {{l(k)-1, l(k), l(k)+1}} για όλα τα k από 1 έως {test_k}: {range_path_prob:.12f}")

    # Υπολογισμός για πλήρη σειρά βημάτων
    exact_path_prob, range_path_prob = calculate_path_probabilities(1000)
    print(f"1) Πιθανότητα η C_k να είναι ακριβώς l(k) για όλα τα k από 1 έως 1000: {exact_path_prob:.12f}")
    print(
        f"2) Πιθανότητα η C_k να ανήκει στο {{l(k)-1, l(k), l(k)+1}} για όλα τα k από 1 έως 1000: {range_path_prob:.12f}")