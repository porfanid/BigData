## ✅ Τι Συμβαίνει:
### Οι **Bloom Filters** έχουν **ένα tradeoff**:
- **Λίγες συναρτήσεις κατακερματισμού (k)** →  
  → **Μεγαλύτερο false positive rate**, **περισσότερα "ΝΑΙ"**  
  → Επομένως, **περισσότερα routers ισχυρίζονται ψευδώς ότι έχουν δει ένα μήνυμα**  
  → Αυξάνεται η πιθανότητα να **καταλήξεις σε περισσότερους από έναν "δημιουργούς"**, και να **αποτύχεις** στην ιχνηλάτηση.  
  → Παρόλα αυτά, σε **1 hash function**, είχες 91.290 επιτυχημένες ιχνηλατήσεις επειδή υπήρχαν **αρκετά χαλαρές συνθήκες**.

- **Πολλές συναρτήσεις κατακερματισμού (k)** →  
  → **Μειώνεται το false positive rate**, αλλά το Bloom Filter γίνεται **πιο αυστηρό**  
  → **Χάνεις την πληροφορία** για κάποια μηνύματα που έπρεπε να έχουν καταγραφεί  
  → Άρα, **μερικά μηνύματα δεν "φαίνονται" πουθενά στο δίκτυο** → **0 επιτυχημένες ιχνηλατήσεις**  
  → Σε **10 hash functions**, ο χώρος μνήμης (10.000 bits) **δεν επαρκεί** και έχεις **πολλά false negatives** (που θεωρητικά δεν υπάρχουν, αλλά πρακτικά με συγκρούσεις και περιορισμό bits, δεν "γράφονται" ποτέ στα φίλτρα).

---

## ✅ Θεωρητική Βάση Bloom Filter  
Το **false positive rate** του Bloom Filter είναι:  
\[
f = \left(1 - e^{-k \cdot n / m}\right)^k
\]  
όπου:
- **n** = αριθμός στοιχείων στο φίλτρο (π.χ., πόσα μηνύματα δέχτηκε το router)
- **m** = bits του φίλτρου (10.000 bits στο σενάριό σου)
- **k** = αριθμός hash functions

➡️ Όταν αυξάνεις **k**:
- Αν το **m** παραμένει ίδιο (10.000), ο **κορεσμός** του φίλτρου γίνεται πολύ πιο γρήγορα!
- Αυτό προκαλεί **collisions**, δηλαδή πολλοί δείκτες ενημερώνονται στο ίδιο bit.
- Πολύ μεγάλο **k** → πολύ μεγάλος **κορεσμός** → χάνεις "πραγματικές" καταγραφές.

---

## ✅ Γιατί 5 και 10 hash functions δίνουν **σχεδόν 0 επιτυχία**
- Τα Bloom Filters είναι **υποκορεσμένα** → σχεδόν **κανένα router δεν ισχυρίζεται ότι είδε τα μηνύματα**, ακόμα κι αν τα είδε.
- Οι **hash functions** γεμίζουν γρήγορα το φίλτρο και δεν αφήνουν χώρο για ακριβείς εγγραφές.
- Η **μνήμη φίλτρου (10.000 bits)** είναι μικρή για 100.000 μηνύματα με **5 ή 10 hash functions** → overfitting, saturation.

---

## ✅ Πώς να το εξηγήσεις στην αναφορά:
### Γενικό Παράδειγμα Συμπερασμάτων:
> **Με χαμηλό αριθμό hash functions** (π.χ., 1 ή 2), παρατηρούμε υψηλά false positive rates, με αποτέλεσμα να εμφανίζονται πολλαπλοί πιθανοί δημιουργοί σε κάθε ιχνηλάτηση, μειώνοντας την ακρίβεια.  
> **Με αυξημένο αριθμό hash functions** (3 έως 10), το σύστημα γίνεται υπερβολικά αυστηρό λόγω του περιορισμένου διαθέσιμου χώρου μνήμης (10.000 bits), με αποτέλεσμα σημαντική μείωση των επιτυχημένων ιχνηλατήσεων.  
> Η καλύτερη απόδοση επιτυγχάνεται με **ενδιάμεσες τιμές k**, εφόσον η μνήμη του φίλτρου αυξηθεί ανάλογα.

---

## ✅ Πώς να το **βελτιώσεις** αν θέλεις:
1. **Αύξησε το μέγεθος του φίλτρου (m):**
   - Από 10.000 → 50.000 ή 100.000 bits.
   - Θα αντέχει περισσότερα hash functions χωρίς κορεσμό.
   
2. **Προσαρμόσιμο μέγεθος ανά router:**
   - Routers με πολλά εισερχόμενα μηνύματα να έχουν **μεγαλύτερα φίλτρα**.

3. **Βελτίωση στο δίκτυο:**
   - Χαμηλότερος βαθμός κόμβων → μικρότερη πιθανότητα "συμφόρησης" στα φίλτρα.

---

## ✅ TL;DR
✔️ Τα αποτελέσματά σου είναι **λογικά** και **σωστά εξηγημένα** από τη θεωρία των Bloom Filters.  
✔️ Η **επιτυχία μειώνεται** όσο αυξάνεις τα hash functions χωρίς να προσαρμόζεις το μέγεθος του Bloom Filter.
